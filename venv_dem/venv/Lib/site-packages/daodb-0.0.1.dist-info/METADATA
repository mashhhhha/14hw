Metadata-Version: 2.1
Name: daodb
Version: 0.0.1
Summary: Declassed Append-Only Database
Home-page: https://declassed.art/repository/daodb
Author: AXY
Author-email: axy@declassed.art
License: UNKNOWN
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: Unix
Classifier: Intended Audience :: Developers
Classifier: Development Status :: 1 - Planning
Classifier: Topic :: Database :: Database Engines/Servers
Requires-Python: >=3.6
Description-Content-Type: text/plain

DAO DB
======

Declassed Append-Only Database

Example
-------

from daodb import JsonDaoDB

with JsonDaoDB('test', 'w') as db:
    db.append({'foo': 'bar'})
    db.append({'bar': 'foo'})
    for i, record in enumerate(db):
        print(i, record)


Database structure
------------------

* data file
* index file

Index file contains positions of records except first one which is always zero, and the position for new record.
Thus, the number of items in the index file equals to the number of records.

Record id is implicit, it's the index of the record.
Thus, to get a record by id, read offsets from the index file and then read the record from data file.

Algorithm
---------

Write:
* lock index file exclusively
* get position for the new record from the index file
* append new record to the data file
* write new size of data file to the index file
* release file lock

Read item by id:
* Given that id is the index of record, seek to id * 16 in the index file.
* Read the position of the record and the position of the next record from the index file, 16 bytes total.
* Read the record from the data file, the size of record is calculated as a difference between positions.

No lock is necessary for read operation.
That's because append is atomic and the data written to the index file (16 bytes)
will never be split across pages to make this bug take into effect: https://bugzilla.kernel.org/show_bug.cgi?id=55651


