'''
The basic implementation with records as binary data.

XXX use sync? -- from atomicwrites

:copyright: Copyright 2022 AXY axy@declassed.art
:license: BSD, see LICENSE for details.
'''

import fcntl
import os
import struct
import threading

class DaoDBFiles:
    '''
    This is a helper class that encapsulates database files.
    '''
    def open_db_files(self, base_path, mode):
        if mode not in ['r', 'w']:
            raise Exception(f'Wrong mode: {mode}')
        self.index_file = None
        self.data_file = None
        try:
            self.index_file = DaoDBIndexFile(base_path, mode)
            self.data_file = DaoDBDataFile(base_path, mode)
        except:
            self.close()
            raise

    def __del__(self):
        self.close()

    def close(self):
        if self.index_file:
            self.index_file.close()
            self.index_file = None
        if self.data_file:
            self.data_file.close()
            self.data_file = None


def _make_open_flags(mode):
    '''
    `mode`: 'r' or 'w'.
    Return flags for `os.open`.
    '''
    flags = os.O_CREAT
    if mode == 'r':
        flags |= os.O_RDONLY
    else:
        flags |= os.O_RDWR
    return flags


class DaoDB(DaoDBFiles):

    def __init__(self, base_path, mode='r'):
        self.base_path = base_path
        self.rlock = threading.RLock()
        self.open_db_files(base_path, mode)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        self.close()

    def __iter__(self):
        # open files again for distinct seek operations
        db_files = DaoDBFiles()
        db_files.open_db_files(self.base_path, 'r')
        try:
            pos = 0
            while True:
                next_pos = db_files.index_file.read_entry()
                if next_pos is None:
                    break
                size = next_pos - pos
                data = self.load_record(db_files.data_file, pos, size)
                yield data
                pos = next_pos
        finally:
            db_files.close()

    def __getitem__(self, key):
        if isinstance(key, int):
            with self.rlock:
                if key < 0:
                    count = self.count()
                    record_id = count + key
                else:
                    record_id = key
                if record_id < 0 or record_id >= count:
                    raise IndexError(f'Record index {key} out of range 0..{count}')
                return self.read(record_id)
        elif isinstance(key, slice):
            raise NotImplementedError()
        else:
            raise TypeError(f'Record indices must be integers or slices, not {type(key).__name__}')

    def load_record(self, data_file, pos, size):
        return data_file.read(pos, size)

    def read(self, record_id):
        with self.rlock:
            if record_id == 0:
                pos = 0
                next_pos = self.index_file.read_nth_entry(0)
            else:
                pos = self.index_file.read_nth_entry(record_id - 1)
                next_pos = self.index_file.read_entry()
            if next_pos is None:
                return None
            else:
                size = next_pos - pos
                return self.load_record(self.data_file, pos, size)

    def append(self, data):
        '''
        Append new record and return its index (i.e. record id)
        '''
        with self.rlock:
            with self.index_file:
                # If previous append was unsuccessfull, the data file may contain garbage at the end.
                # Get the position for writing from the index file instead of simply appending.
                pos = self.index_file.read_last_entry()
                if pos is None:
                    pos = 0
                next_pos = self.data_file.write(pos, data)
                return self.index_file.append(next_pos)

    def count(self):
        with self.rlock:
            return self.index_file.count()


class DaoDBIndexFile:

    entry_format = 'Q'
    entry_size = struct.calcsize(entry_format)

    def __init__(self, base_path, mode):
        self.fd = None
        self.fd = os.open(base_path + '.index', _make_open_flags(mode))

    def __del__(self):
        self.close()

    def __enter__(self):
        self.lock()
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        self.unlock()

    def close(self):
        if self.fd is not None:
            os.close(self.fd)
            self.fd = None

    def lock(self):
        fcntl.lockf(self.fd, fcntl.LOCK_EX)

    def unlock(self):
        fcntl.lockf(self.fd, fcntl.LOCK_UN)

    def read_entry(self):
        '''
        Read entry at current position.
        '''
        entry = os.read(self.fd, self.entry_size)
        if len(entry) == self.entry_size:
            return struct.unpack(self.entry_format, entry)[0]
        else:
            return None

    def read_nth_entry(self, n):
        '''
        Read Nth entry.
        '''
        os.lseek(self.fd, n * self.entry_size, os.SEEK_SET)
        return self.read_entry()

    def read_last_entry(self):
        '''
        Read last entry.
        '''
        try:
            os.lseek(self.fd, -self.entry_size, os.SEEK_END)
        except OSError:
            # index file is empty
            return None
        return self.read_entry()

    def append(self, entry):
        '''
        Append new entry and return its index in the file.
        '''
        pos = os.lseek(self.fd, 0, os.SEEK_END)
        os.write(self.fd, struct.pack(self.entry_format, entry))
        return pos // self.entry_size

    def count(self):
        return os.lseek(self.fd, 0, os.SEEK_END) // self.entry_size


class DaoDBDataFile:

    def __init__(self, base_path, mode):
        self.fd = None
        self.fd = os.open(base_path + '.data', _make_open_flags(mode))

    def close(self):
        if self.fd is not None:
            os.close(self.fd)
            self.fd = None

    def __del__(self):
        self.close()

    def read(self, pos, size):
        '''
        Read `size` bytes from data file starting from `pos`.
        '''
        os.lseek(self.fd, pos, os.SEEK_SET)
        return os.read(self.fd, size)

    def write(self, pos, data):
        os.lseek(self.fd, pos, os.SEEK_SET)
        bytes_written = os.write(self.fd, data)
        return pos + bytes_written
